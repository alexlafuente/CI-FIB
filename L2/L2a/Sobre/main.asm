;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   lu. oct. 2 2023
; Processor: PIC18F45K22
; Compiler:  MPASM (Proteus)
;====================================================================

;====================================================================
; DEFINITIONS
;====================================================================

#include p18f45k22.inc
config FOSC = HSHP
;========================================================
; VARIABLES
;========================================================
var1 equ 0x20
del equ 0x0D
;========================================================
; RESET and INTERRUPT VECTORS
;========================================================
RST code 0x0
goto Start
;=================
;=======================================
; CODE SEGMENT
;========================================================
PGM code
Start
   movlw B'00000001'; W=0
   ; Configurar PORTs
   movlb 0xF		; Preparar BSRs per als banked SFRs
   clrf PORTB, 1	; Borrar PORTB
   clrf PORTC, 1
   clrf PORTD, 1
   clrf LATB,1		; Mètode altern per a borrar l'output
   clrf LATC,1
   clrf LATD,1
   movlw 0xF8		; W = (0b 1111 1000)
   movwf ANSELB, 1	; Sel·leccionar RB0, RB1 i RB2 com a digitals
   movlw 0xFE		
   movwf ANSELC, 1	; RC0 digital
   movlw 0xFF
   movwf ANSELD, 1	; Tot RD digital
   movlw 0xF9		;  W = (0b 1111 1001)
   movwf TRISB, 1	; Sel·leccionar RB0 com a input i RB1, RB2 com a output (RB3..RB7 com a input, però no els utilitzarem)
   movlw 0xFF		
   movwf TRISC, 1	; Tot RC inputs
   movlw 0x00
   movwf TRISD, 1	; Tot RD outputs
Loop
   ; Llegir RB0 i actualitzar RB1
   btfss PORTB, 0, 1	; si al bit 0 de PORTB hi ha un 1, se salta la següent instrucció (if RB0 == 1 --> skip next)
   bsf LATB, 1, 1	; posar un 1 al bit 1 del RB (RB1 = 1)
   btfsc PORTB, 0, 1	; si al bit 0 de PORTB hi ha un 0, se salta la següent instrucció (if RB0 == 0 --> skip next)
   bcf LATB, 1, 1	; posar un 0 al bit 1 del RB (RB1 = 0)
   call delay_40cicles
   
   goto Loop
   
delay_40cicles
    ; Posar el valor a RB2 i esperar uns 40 cicles
    btg PORTB, 2, 1	; operació NOT al bit 2 RB (RB2)
    
    movlw 0x0C  	;       1c      
    movwf 30, 0 	;       1c                        (2 + 3x + 3 = 40) --> fòrmula per a calcular el nombre que moure a W (12)
    DelayLoop
        decfsz 30, 1, 0 ;   1c      3c
        goto DelayLoop  ;   2c      x
        return
 

    
    
    
    
    
 delay50ms
   lp_cnt0 equ 0x20;	lp_cnt0 = 0x20
   lp_cnt1 equ 0x21;	lp_cnt1 = 0x21
   movlw D’100’;		W = 100
   movwf lp_cnt0,A;	[0x020] = W = 100
   loop0 movlw D’200’;	W = 200	
   loop1 movwf lp_cnt1,A;	[0x021] = W = 200
   nop; 			1 instruction cycle
   nop; 			1 instruction cycle
   nop; 			1 instruction cycle

   decfsz lp_cnt1,F,A ;
   goto loop1
   decfsz lp_cnt0,F,A
   goto loop0 ; 1 sec delay.

;====================================================================
      END
