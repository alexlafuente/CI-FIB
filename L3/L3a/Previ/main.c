/* Main.c file generated by New Project wizard
 *
 * Created:   do. oct. 14 2023
 * Processor: PIC18F45K22
 * Compiler:  MPLAB XC8
 */

#include <xc.h>
#include <stdlib.h>
#include <time.h>
#include "config.h"
#define _XTAL_FREQ 8000000

// El num de la pos. del vector, es correspon al valor contingut en aquesta, per representar-ho al led
int transform[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x67};

// Retorna nombre pseudoaleatori entre 0 i 99, a partir del nombre seed
int randomNumber(int seed){
   // Generació de nombre aleatori
      srand(seed);
      return rand() % 99; // rang del nombre aleatori [0, 99]
}



// Agafa la segona xifra de ranNum, i ilumina el led amb aquesta, a la secció dreta. Després fa el mateix, amb la primera xifra, a la esquerra
void selecciona(int ranNum, int select){
   int desp = 0;
   int dret;
   int esq;
   if(ranNum >= 10){
       dret = ranNum % 10; // dret és la segona xifra de ranNum (ranNum << 3)
       esq = ranNum / 10; // s'intenta que esq sigui la primera xifra de ranNum (ranNum >> 3);
   }
   else{
      dret = ranNum;
      esq = 0;
   }
   /* if(dret * 8)
   int esq = ranNum / 10; // s'intenta que esq sigui la primera xifra de ranNum (ranNum >> 3)
   if(esq * 8 != ranNum){ // Imprecisió a nivell de bit a l'hora de fer el desplaçament
      esq = esq - 1;
   }
   */
   PORTD = 0; // Intentar tractar ghosting
   PORTA = select;
   __delay_ms(7); // Intentar tractar ghosting
   PORTD = transform[dret]; // Il·luminem secció dreta
   if(desp == 0){
      __delay_ms(7);
      PORTA = PORTA << 1; // Passem a la secció de l'esquerra
      PORTD = transform[esq]; // Il·luminem secció esquerra
      __delay_ms(7);
      desp = 1;
   }
   return;
}

void main(void){
   ANSELA = 0; // All pins as digital
   ANSELB = 0x00;
   ANSELC= 0x00;
   ANSELD= 0;
   ANSELE= 0;
   TRISA = 0x00; // Tot TRISA = output
   TRISC = 0xFF; // Tot TRISC = input
   TRISD = 0x00; // Tot TRISD = output
   PORTA = 0;
   PORTC = 0;
   PORTD = 0;
   int ences1 = 0;
   int ences2 = 0;
   int b = 0;
   int c = 0;
   int d = 0;
   int e = 0;
   int randGen = 0;
   int numPress = 0;
   int ranNum1 = 0;
   int ranNum2 = 0;
   while(1) {
      if(PORTCbits.RC7 == 1 && b == 0){ // Flanc ascendent a RC7
	 ranNum1 = randomNumber(randGen);
	 b = 1;
	 ences1 = 1;
      }
      if(ences1 == 1){
	 selecciona(ranNum1, 0x01); // Apuntem a la dreta de la segona secció dels leds (0x01)
      }
      if(PORTCbits.RC7 == 0 && b == 1){ // Flanc descendent a RC7
	 b = 0;
      }
      if(PORTCbits.RC5 == 1 && c == 0){ // Flanc ascendent a RC5
	 ranNum2 = randomNumber(randGen);
	 c = 1;
	 ences2 = 1;
      }
      if(ences2 == 1){
	 selecciona(ranNum2, 0x04); // Apuntem a la dreta de la primera secció dels leds (0x04)
      }
      if(PORTCbits.RC5 == 0 && c == 1){ // Flanc descendent a RC5
	 c = 0;
      }
      if(PORTCbits.RC6 == 0 && d == 1 && ences1 == 1 && ences2 == 1){ // Flanc descendent a RC6
	 int mul = ranNum1 * ranNum2;
	 ranNum1 = mul % 100; // 2 últimes xifres
	 
	 ranNum2 = mul / 100; // 2 primeres xifres
	 d = 0;
      }
      if(PORTCbits.RC6 == 1 && d == 0){ // Flanc ascendent a RC6
	 d = 1;
      }
      if(PORTCbits.RC4 == 0 && e == 1){ // Flanc descendent a RC4
	 if(numPress == 0){
	    // Apagar la senyal d'encés i la informació del port d
	    ences1 = 0;
	    ences2 = 0;
	    PORTD = 0;
	    numPress = 1;
	 }
	 else{ // La única possibilitat restant és que sigui 1
	    ences1 = 1;
	    ences2 = 1;
	    numPress = 0;
	 }
	 e = 0;
      }
      if(PORTCbits.RC4 == 1 && e == 0){
	 e = 1;
      }
      ++randGen;
   }
}